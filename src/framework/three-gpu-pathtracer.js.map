{"version":3,"file":"index.module.js","sources":["../src/materials/MaterialBase.js","../src/materials/BlendMaterial.js","../src/core/PathTracingRenderer.js","../src/utils/GeometryPreparationUtils.js","../src/core/PathTracingSceneGenerator.js","../src/core/DynamicPathTracingSceneGenerator.js","../src/core/MaterialReducer.js","../src/core/PhysicalCamera.js","../src/uniforms/MaterialsTexture.js","../src/uniforms/Pass.js","../src/uniforms/RenderTarget2DArray.js","../src/uniforms/EquirectHdrInfoUniform.js","../src/uniforms/PhysicalCameraUniform.js","../src/shader/shaderUtils.js","../src/utils/BlurredEnvMapGenerator.js","../src/shader/shaderStructs.js","../src/shader/shaderGGXFunctions.js","../src/shader/shaderMaterialSampling.js","../src/shader/shaderEnvMapSampling.js","../src/shader/shaderLightSampling.js","../src/uniforms/LightsTexture.js","../src/materials/PhysicalPathTracingMaterial.js","../src/index.js"],"sourcesContent":["import { ShaderMaterial } from 'three';\r\n\r\nexport class MaterialBase extends ShaderMaterial {\r\n\r\n\tconstructor( shader ) {\r\n\r\n\t\tsuper( shader );\r\n\r\n\t\tfor ( const key in this.uniforms ) {\r\n\r\n\t\t\tObject.defineProperty( this, key, {\r\n\r\n\t\t\t\tget() {\r\n\r\n\t\t\t\t\treturn this.uniforms[ key ].value;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tset( v ) {\r\n\r\n\t\t\t\t\tthis.uniforms[ key ].value = v;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\r\n\tsetDefine( name, value = undefined ) {\r\n\r\n\t\tif ( value === undefined || value === null ) {\r\n\r\n\t\t\tif ( name in this.defines ) {\r\n\r\n\t\t\t\tdelete this.defines[ name ];\r\n\t\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this.defines[ name ] !== value ) {\r\n\r\n\t\t\t\tthis.defines[ name ] = value;\r\n\t\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { NoBlending } from 'three';\r\nimport { MaterialBase } from './MaterialBase.js';\r\n\r\nexport class BlendMaterial extends MaterialBase {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\ttarget1: { value: null },\r\n\t\t\t\ttarget2: { value: null },\r\n\t\t\t\topacity: { value: 1.0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tuniform sampler2D target1;\r\n\t\t\t\tuniform sampler2D target2;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\r\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\r\n\r\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\r\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\r\n\r\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\r\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { BlendMaterial } from '../materials/BlendMaterial.js';\r\n\r\nfunction* renderTask() {\r\n\r\n\tconst {\r\n\t\t_renderer,\r\n\t\t_fsQuad,\r\n\t\t_blendQuad,\r\n\t\t_primaryTarget,\r\n\t\t_blendTargets,\r\n\t\talpha,\r\n\t\tcamera,\r\n\t\tmaterial,\r\n\t} = this;\r\n\r\n\tconst blendMaterial = _blendQuad.material;\r\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\tblendMaterial.opacity = 1 / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NoBlending;\r\n\t\t\tmaterial.opacity = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.opacity = 1 / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NormalBlending;\r\n\r\n\t\t}\r\n\r\n\t\tconst w = _primaryTarget.width;\r\n\t\tconst h = _primaryTarget.height;\r\n\t\tmaterial.resolution.set( w, h );\r\n\t\tmaterial.seed ++;\r\n\r\n\t\tconst tx = this.tiles.x || 1;\r\n\t\tconst ty = this.tiles.y || 1;\r\n\t\tconst totalTiles = tx * ty;\r\n\t\tconst dprInv = ( 1 / _renderer.getPixelRatio() );\r\n\t\tfor ( let y = 0; y < ty; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < tx; x ++ ) {\r\n\r\n\t\t\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\r\n\t\t\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\r\n\t\t\t\t// An orthographic projection matrix will always have the bottom right element == 1\r\n\t\t\t\t// And a perspective projection matrix will always have the bottom right element == 0\r\n\t\t\t\tmaterial.setDefine( 'CAMERA_TYPE', camera.projectionMatrix.elements[ 15 ] > 0 ? 1 : 0 );\r\n\r\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\r\n\r\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\r\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t\t\t_renderer.setScissorTest( true );\r\n\t\t\t\t_renderer.setScissor(\r\n\t\t\t\t\tdprInv * Math.ceil( x * w / tx ),\r\n\t\t\t\t\tdprInv * Math.ceil( ( ty - y - 1 ) * h / ty ),\r\n\t\t\t\t\tdprInv * Math.ceil( w / tx ),\r\n\t\t\t\t\tdprInv * Math.ceil( h / ty ) );\r\n\t\t\t\t_renderer.autoClear = false;\r\n\t\t\t\t_fsQuad.render( _renderer );\r\n\r\n\t\t\t\t_renderer.setScissorTest( false );\r\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\t\t\t\t_renderer.autoClear = ogAutoClear;\r\n\r\n\t\t\t\tif ( alpha ) {\r\n\r\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\r\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\r\n\r\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\r\n\t\t\t\t\t_blendQuad.render( _renderer );\r\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.samples += ( 1 / totalTiles );\r\n\r\n\t\t\t\tyield;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\r\n\r\n\t\tthis.samples = Math.round( this.samples );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst ogClearColor = new Color();\r\nexport class PathTracingRenderer {\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._fsQuad.material;\r\n\r\n\t}\r\n\r\n\tset material( v ) {\r\n\r\n\t\tthis._fsQuad.material = v;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\r\n\r\n\t}\r\n\r\n\tset alpha( v ) {\r\n\r\n\t\tif ( ! v ) {\r\n\r\n\t\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\t\tthis._blendTargets[ 1 ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis._alpha = v;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tget alpha() {\r\n\r\n\t\treturn this._alpha;\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.camera = null;\r\n\t\tthis.tiles = new Vector2( 1, 1 );\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis.stableNoise = false;\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._alpha = false;\r\n\t\tthis._fsQuad = new FullScreenQuad( null );\r\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\r\n\t\tthis._task = null;\r\n\r\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t} );\r\n\t\tthis._blendTargets = [\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t} ),\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t} ),\r\n\t\t];\r\n\r\n\t}\r\n\r\n\tsetSize( w, h ) {\r\n\r\n\t\tthis._primaryTarget.setSize( w, h );\r\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\r\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._primaryTarget.dispose();\r\n\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\tthis._blendTargets[ 1 ].dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\t\tthis._blendQuad.dispose();\r\n\t\tthis._task = null;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\r\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.getClearColor( ogClearColor );\r\n\r\n\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\r\n\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._task = null;\r\n\r\n\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\tthis.material.seed = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tif ( ! this._task ) {\r\n\r\n\t\t\tthis._task = renderTask.call( this );\r\n\r\n\t\t}\r\n\r\n\t\tthis._task.next();\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\nimport { mergeBufferGeometries, mergeVertices } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\r\nexport function getGroupMaterialIndicesAttribute( geometry, materials, allMaterials ) {\r\n\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = geometry.attributes.position;\r\n\tconst vertCount = posAttr.count;\r\n\tconst materialArray = new Uint8Array( vertCount );\r\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\r\n\tlet groups = geometry.groups;\r\n\tif ( groups.length === 0 ) {\r\n\r\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst start = group.start;\r\n\t\tconst count = group.count;\r\n\t\tconst endCount = Math.min( count, totalCount - start );\r\n\r\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\r\n\t\tconst materialIndex = allMaterials.indexOf( mat );\r\n\r\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\r\n\r\n\t\t\tlet index = start + j;\r\n\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\tindex = indexAttr.getX( index );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialArray[ index ] = materialIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn new BufferAttribute( materialArray, 1, false );\r\n\r\n}\r\n\r\nexport function trimToAttributes( geometry, attributes ) {\r\n\r\n\t// trim any unneeded attributes\r\n\tif ( attributes ) {\r\n\r\n\t\tfor ( const key in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributes.includes( key ) ) {\r\n\r\n\t\t\t\tgeometry.deleteAttribute( key );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function setCommonAttributes( geometry, options ) {\r\n\r\n\tconst { attributes = [], normalMapRequired = false } = options;\r\n\r\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\r\n\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\r\n\r\n\t\tif ( normalMapRequired ) {\r\n\r\n\t\t\t// computeTangents requires an index buffer\r\n\t\t\tif ( geometry.index === null ) {\r\n\r\n\t\t\t\tgeometry = mergeVertices( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.index ) {\r\n\r\n\t\t// TODO: compute a typed array\r\n\t\tconst indexCount = geometry.attributes.position.count;\r\n\t\tconst array = new Array( indexCount );\r\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\r\n\r\n\t\t\tarray[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.setIndex( array );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function mergeMeshes( meshes, options = {} ) {\r\n\r\n\toptions = { attributes: null, cloneGeometry: true, ...options };\r\n\r\n\tconst transformedGeometry = [];\r\n\tconst materialSet = new Set();\r\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t// save any materials\r\n\t\tconst mesh = meshes[ i ];\r\n\t\tif ( mesh.visible === false ) continue;\r\n\r\n\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\tmesh.material.forEach( m => materialSet.add( m ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialSet.add( mesh.material );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst materials = Array.from( materialSet );\r\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t// ensure the matrix world is up to date\r\n\t\tconst mesh = meshes[ i ];\r\n\t\tif ( mesh.visible === false ) continue;\r\n\r\n\t\tmesh.updateMatrixWorld();\r\n\r\n\t\t// apply the matrix world to the geometry\r\n\t\tconst originalGeometry = meshes[ i ].geometry;\r\n\t\tconst geometry = options.cloneGeometry ? originalGeometry.clone() : originalGeometry;\r\n\t\tgeometry.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t// ensure our geometry has common attributes\r\n\t\tsetCommonAttributes( geometry, {\r\n\t\t\tattributes: options.attributes,\r\n\t\t\tnormalMapRequired: ! ! mesh.material.normalMap,\r\n\t\t} );\r\n\t\ttrimToAttributes( geometry, options.attributes );\r\n\r\n\t\t// create the material index attribute\r\n\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, mesh.material, materials );\r\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\r\n\r\n\t\ttransformedGeometry.push( geometry );\r\n\r\n\t}\r\n\r\n\tconst textureSet = new Set();\r\n\tmaterials.forEach( material => {\r\n\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tconst geometry = mergeBufferGeometries( transformedGeometry, false );\r\n\tconst textures = Array.from( textureSet );\r\n\treturn { geometry, materials, textures };\r\n\r\n}\r\n","import { Mesh } from 'three';\r\nimport { SAH, MeshBVH, StaticGeometryGenerator } from 'three-mesh-bvh';\r\nimport { mergeMeshes } from '../utils/GeometryPreparationUtils.js';\r\n\r\nexport class PathTracingSceneGenerator {\r\n\r\n\tprepScene( scene ) {\r\n\r\n\t\tconst meshes = [];\r\n\t\tconst lights = [];\r\n\t\tscene.traverse( c => {\r\n\r\n\t\t\tif ( c.isSkinnedMesh || c.isMesh && c.morphTargetInfluences ) {\r\n\r\n\t\t\t\tconst generator = new StaticGeometryGenerator( c );\r\n\t\t\t\tgenerator.applyWorldTransforms = false;\r\n\t\t\t\tconst mesh = new Mesh(\r\n\t\t\t\t\tgenerator.generate(),\r\n\t\t\t\t\tc.material,\r\n\t\t\t\t);\r\n\t\t\t\tmesh.matrixWorld.copy( c.matrixWorld );\r\n\t\t\t\tmesh.matrix.copy( c.matrixWorld );\r\n\t\t\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t} else if ( c.isMesh ) {\r\n\r\n\t\t\t\tmeshes.push( c );\r\n\r\n\t\t\t} else if ( c.isRectAreaLight ) {\r\n\r\n\t\t\t\tlights.push( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn {\r\n\t\t\t...mergeMeshes( meshes, {\r\n\t\t\t\tattributes: [ 'position', 'normal', 'tangent', 'uv' ],\r\n\t\t\t} ),\r\n\t\t\tlights\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tgenerate( scene, options = {} ) {\r\n\r\n\t\tconst { materials, textures, geometry, lights } = this.prepScene( scene );\r\n\t\tconst bvhOptions = { strategy: SAH, ...options, maxLeafTris: 1 };\r\n\t\treturn {\r\n\t\t\tscene,\r\n\t\t\tmaterials,\r\n\t\t\ttextures,\r\n\t\t\tlights,\r\n\t\t\tbvh: new MeshBVH( geometry, bvhOptions ),\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferGeometry } from 'three';\r\nimport { StaticGeometryGenerator, MeshBVH } from 'three-mesh-bvh';\r\nimport { setCommonAttributes, getGroupMaterialIndicesAttribute } from '../utils/GeometryPreparationUtils.js';\r\n\r\nexport class DynamicPathTracingSceneGenerator {\r\n\r\n\tget initialized() {\r\n\r\n\t\treturn Boolean( this.bvh );\r\n\r\n\t}\r\n\r\n\tconstructor( scene ) {\r\n\r\n\t\tthis.scene = scene;\r\n\t\tthis.bvh = null;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.materials = null;\r\n\t\tthis.textures = null;\r\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( scene );\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.bvh = null;\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.materials = null;\r\n\t\tthis.textures = null;\r\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( this.scene );\r\n\r\n\t}\r\n\r\n\tdispose() {}\r\n\r\n\tgenerate() {\r\n\r\n\t\tconst { scene, staticGeometryGenerator, geometry } = this;\r\n\t\tif ( this.bvh === null ) {\r\n\r\n\t\t\tconst attributes = [ 'position', 'normal', 'tangent', 'uv' ];\r\n\t\t\tscene.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isMesh ) {\r\n\r\n\t\t\t\t\tconst normalMapRequired = ! ! c.material.normalMap;\r\n\t\t\t\t\tsetCommonAttributes( c.geometry, { attributes, normalMapRequired } );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst textureSet = new Set();\r\n\t\t\tconst materials = staticGeometryGenerator.getMaterials();\r\n\t\t\tmaterials.forEach( material => {\r\n\r\n\t\t\t\tfor ( const key in material ) {\r\n\r\n\t\t\t\t\tconst value = material[ key ];\r\n\t\t\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tstaticGeometryGenerator.attributes = attributes;\r\n\t\t\tstaticGeometryGenerator.generate( geometry );\r\n\r\n\t\t\tconst materialIndexAttribute = getGroupMaterialIndicesAttribute( geometry, materials, materials );\r\n\t\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\r\n\t\t\tgeometry.clearGroups();\r\n\r\n\t\t\tthis.bvh = new MeshBVH( geometry );\r\n\t\t\tthis.materials = materials;\r\n\t\t\tthis.textures = Array.from( textureSet );\r\n\r\n\t\t\treturn {\r\n\t\t\t\tbvh: this.bvh,\r\n\t\t\t\tmaterials: this.materials,\r\n\t\t\t\ttextures: this.textures,\r\n\t\t\t\tscene,\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst { bvh } = this;\r\n\t\t\tstaticGeometryGenerator.generate( geometry );\r\n\t\t\tbvh.refit();\r\n\t\t\treturn {\r\n\t\t\t\tbvh: this.bvh,\r\n\t\t\t\tmaterials: this.materials,\r\n\t\t\t\ttextures: this.textures,\r\n\t\t\t\tscene,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n}\r\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\r\n\r\nfunction isTypedArray( arr ) {\r\n\r\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\r\n\r\n}\r\n\r\nexport class MaterialReducer {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst ignoreKeys = new Set();\r\n\t\tignoreKeys.add( 'uuid' );\r\n\r\n\t\tthis.ignoreKeys = ignoreKeys;\r\n\t\tthis.shareTextures = true;\r\n\t\tthis.textures = [];\r\n\t\tthis.materials = [];\r\n\r\n\t}\r\n\r\n\tareEqual( objectA, objectB ) {\r\n\r\n\t\tconst keySet = new Set();\r\n\t\tconst traverseSet = new Set();\r\n\t\tconst ignoreKeys = this.ignoreKeys;\r\n\r\n\t\tconst traverse = ( a, b ) => {\r\n\r\n\t\t\tif ( a === b ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\r\n\r\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst aIsElement = a instanceof Element;\r\n\t\t\t\tconst bIsElement = b instanceof Element;\r\n\t\t\t\tif ( aIsElement || bIsElement ) {\r\n\r\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn a.src === b.src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\r\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\r\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( a.equals ) {\r\n\r\n\t\t\t\t\treturn a.equals( b );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\r\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\r\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\r\n\r\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttraverseSet.add( a );\r\n\t\t\t\ttraverseSet.add( b );\r\n\r\n\t\t\t\tkeySet.clear();\r\n\t\t\t\tfor ( const key in a ) {\r\n\r\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tkeySet.add( key );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( const key in b ) {\r\n\r\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tkeySet.add( key );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst keys = Array.from( keySet.values() );\r\n\t\t\t\tlet result = true;\r\n\t\t\t\tfor ( const i in keys ) {\r\n\r\n\t\t\t\t\tconst key = keys[ i ];\r\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\r\n\t\t\t\t\tif ( ! result ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttraverseSet.delete( a );\r\n\t\t\t\ttraverseSet.delete( b );\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t};\r\n\r\n\t\treturn traverse( objectA, objectB );\r\n\r\n\t}\r\n\r\n\tprocess( object ) {\r\n\r\n\t\tconst { textures, materials } = this;\r\n\t\tlet replaced = 0;\r\n\r\n\t\tconst processMaterial = material => {\r\n\r\n\t\t\t// Check if another material matches this one\r\n\t\t\tlet foundMaterial = null;\r\n\t\t\tfor ( const i in materials ) {\r\n\r\n\t\t\t\tconst otherMaterial = materials[ i ];\r\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\r\n\r\n\t\t\t\t\tfoundMaterial = otherMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( foundMaterial ) {\r\n\r\n\t\t\t\treplaced ++;\r\n\t\t\t\treturn foundMaterial;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterials.push( material );\r\n\r\n\t\t\t\tif ( this.shareTextures ) {\r\n\r\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\r\n\t\t\t\t\tfor ( const key in material ) {\r\n\r\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\r\n\r\n\t\t\t\t\t\tconst value = material[ key ];\r\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\r\n\r\n\t\t\t\t\t\t\tlet foundTexture = null;\r\n\t\t\t\t\t\t\tfor ( const i in textures ) {\r\n\r\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\r\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\r\n\r\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( foundTexture ) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\ttextures.push( value );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tobject.traverse( c => {\r\n\r\n\t\t\tif ( c.isMesh && c.material ) {\r\n\r\n\t\t\t\tconst material = c.material;\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc.material = processMaterial( material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn { replaced, retained: materials.length };\r\n\r\n\t}\r\n\r\n}\r\n","import { PerspectiveCamera } from 'three';\r\n\r\nexport class PhysicalCamera extends PerspectiveCamera {\r\n\r\n\tset bokehSize( size ) {\r\n\r\n\t\tthis.fStop = this.getFocalLength() / size;\r\n\r\n\t}\r\n\r\n\tget bokehSize() {\r\n\r\n\t\treturn this.getFocalLength() / this.fStop;\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.fStop = 1.4;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 25;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide } from 'three';\r\n\r\nconst MATERIAL_PIXELS = 19;\r\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\r\n\r\nexport class MaterialsTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\r\n\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.type = FloatType;\r\n\t\tthis.wrapS = ClampToEdgeWrapping;\r\n\t\tthis.wrapT = ClampToEdgeWrapping;\r\n\t\tthis.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\tsetCastShadow( materialIndex, cast ) {\r\n\r\n\t\t// invert the shadow value so we default to \"true\" when initializing a material\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\r\n\t\tarray[ index ] = ! cast ? 1 : 0;\r\n\r\n\t}\r\n\r\n\tgetCastShadow( materialIndex ) {\r\n\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 6 * 4 + 0;\r\n\t\treturn ! Boolean( array[ index ] );\r\n\r\n\t}\r\n\r\n\tsetSide( materialIndex, side ) {\r\n\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\r\n\t\tswitch ( side ) {\r\n\r\n\t\tcase FrontSide:\r\n\t\t\tarray[ index ] = 1;\r\n\t\t\tbreak;\r\n\t\tcase BackSide:\r\n\t\t\tarray[ index ] = - 1;\r\n\t\t\tbreak;\r\n\t\tcase DoubleSide:\r\n\t\t\tarray[ index ] = 0;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetSide( materialIndex ) {\r\n\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 2;\r\n\t\tswitch ( array[ index ] ) {\r\n\r\n\t\tcase 0:\r\n\t\t\treturn DoubleSide;\r\n\t\tcase 1:\r\n\t\t\treturn FrontSide;\r\n\t\tcase - 1:\r\n\t\t\treturn BackSide;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tsetMatte( materialIndex, matte ) {\r\n\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\r\n\t\tarray[ index ] = matte ? 1 : 0;\r\n\r\n\t}\r\n\r\n\tgetMatte( materialIndex ) {\r\n\r\n\t\tconst array = this.image.data;\r\n\t\tconst index = materialIndex * MATERIAL_STRIDE + 5 * 4 + 3;\r\n\t\treturn Boolean( array[ index ] );\r\n\r\n\t}\r\n\r\n\tupdateFrom( materials, textures ) {\r\n\r\n\t\tfunction getTexture( material, key, def = - 1 ) {\r\n\r\n\t\t\treturn key in material ? textures.indexOf( material[ key ] ) : def;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getField( material, key, def ) {\r\n\r\n\t\t\treturn key in material ? material[ key ] : def;\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param {Object} material\r\n\t\t * @param {string} textureKey\r\n\t\t * @param {Float32Array} array\r\n\t\t * @param {number} offset\r\n\t\t * @returns {8} number of floats occupied by texture transform matrix\r\n\t\t */\r\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\r\n\r\n\t\t\t// check if texture exists\r\n\t\t\tif ( material[ textureKey ] && material[ textureKey ].isTexture ) {\r\n\r\n\t\t\t\tconst elements = material[ textureKey ].matrix.elements;\r\n\r\n\t\t\t\tlet i = 0;\r\n\r\n\t\t\t\t// first row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t\t// second row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 8;\r\n\r\n\t\t}\r\n\r\n\t\tlet index = 0;\r\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\r\n\r\n\t\tif ( this.image.width !== dimension ) {\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t\tthis.image.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\tthis.image.width = dimension;\r\n\t\t\tthis.image.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = this.image.data;\r\n\r\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\r\n\t\t// can't encode texture ids that way.\r\n\t\t// const intArray = new Int32Array( floatArray.buffer );\r\n\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst m = materials[ i ];\r\n\r\n\t\t\t// color\r\n\t\t\tfloatArray[ index ++ ] = m.color.r;\r\n\t\t\tfloatArray[ index ++ ] = m.color.g;\r\n\t\t\tfloatArray[ index ++ ] = m.color.b;\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\r\n\r\n\t\t\t// metalness & roughness\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.metalnessMap );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = textures.indexOf( m.roughnessMap );\r\n\r\n\t\t\t// transmission & emissiveIntensity\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.0 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t// emission\r\n\t\t\tif ( 'emissive' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\r\n\r\n\t\t\t// normals\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\r\n\t\t\tif ( 'normalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\r\n\r\n \t\t\t} else {\r\n\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n \t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\r\n\r\n\t\t\t// side & matte\r\n\t\t\tfloatArray[ index ++ ] = m.opacity;\r\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\r\n\t\t\tindex ++; // side\r\n\t\t\tindex ++; // matte\r\n\r\n\t\t\tindex ++; // shadow\r\n\t\t\tindex ++;\r\n\t\t\tindex ++;\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// map transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\r\n\r\n\t\t\t// metalnessMap transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\r\n\r\n\t\t\t// roughnessMap transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\r\n\r\n\t\t\t// transmissionMap transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\r\n\r\n\t\t\t// emissiveMap transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\r\n\r\n\t\t\t// normalMap transform\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tOrthographicCamera,\r\n\tPlaneGeometry,\r\n\tMesh\r\n} from 'three';\r\n\r\nfunction Pass() {\r\n\r\n\t// if set to true, the pass is processed by the composer\r\n\tthis.enabled = true;\r\n\r\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\tthis.needsSwap = true;\r\n\r\n\t// if set to true, the pass clears its buffer before rendering\r\n\tthis.clear = false;\r\n\r\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\r\n\tthis.renderToScreen = false;\r\n\r\n}\r\n\r\nObject.assign( Pass.prototype, {\r\n\r\n\tsetSize: function ( /* width, height */ ) {},\r\n\r\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// Helper for passes that need to fill the viewport with a single quad.\r\n\r\n// Important: It's actually a hack to put FullScreenQuad into the Pass namespace. This is only\r\n// done to make examples/js code work. Normally, FullScreenQuad should be exported\r\n// from this module like Pass.\r\n\r\nexport const FullScreenQuad = ( function () {\r\n\r\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\tvar geometry = new PlaneGeometry( 2, 2 );\r\n\r\n\tvar FullScreenQuad = function ( material ) {\r\n\r\n\t\tthis._mesh = new Mesh( geometry, material );\r\n\r\n\t};\r\n\r\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this._mesh.material;\r\n\r\n\t\t},\r\n\r\n\t\tset: function ( value ) {\r\n\r\n\t\t\tthis._mesh.material = value;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tObject.assign( FullScreenQuad.prototype, {\r\n\r\n\t\tdispose: function () {\r\n\r\n\t\t\tthis._mesh.geometry.dispose();\r\n\r\n\t\t},\r\n\r\n\t\trender: function ( renderer ) {\r\n\r\n\t\t\trenderer.render( this._mesh, camera );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn FullScreenQuad;\r\n\r\n} )();\r\n\r\nexport { Pass };\r\n","import {\r\n\tWebGLArrayRenderTarget,\r\n\tRGBAFormat,\r\n\tUnsignedByteType,\r\n\tMeshBasicMaterial,\r\n\tColor,\r\n\tRepeatWrapping,\r\n\tLinearFilter,\r\n\tNoToneMapping,\r\n\tDataTexture3D,\r\n} from 'three';\r\nimport { FullScreenQuad } from './Pass.js';\r\n\r\nconst prevColor = new Color();\r\nexport class RenderTarget2DArray extends DataTexture3D {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tconst tex = this.texture;\r\n\t\ttex.format = RGBAFormat;\r\n\t\ttex.type = UnsignedByteType;\r\n\t\ttex.minFilter = LinearFilter;\r\n\t\ttex.magFilter = LinearFilter;\r\n\t\ttex.wrapS = RepeatWrapping;\r\n\t\ttex.wrapT = RepeatWrapping;\r\n\t\ttex.setTextures = ( ...args ) => {\r\n\r\n\t\t\tthis.setTextures( ...args );\r\n\r\n\t\t};\r\n\r\n\t\tconst fsQuad = new FullScreenQuad( new MeshBasicMaterial() );\r\n\t\tthis.fsQuad = fsQuad;\r\n\r\n\t}\r\n\r\n\tsetTextures( renderer, width, height, textures ) {\r\n\r\n\t\t// save previous renderer state\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevToneMapping = renderer.toneMapping;\r\n\t\tconst prevAlpha = renderer.getClearAlpha();\r\n\t\trenderer.getClearColor( prevColor );\r\n\r\n\t\t// resize the render target and ensure we don't have an empty texture\r\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\r\n\t\tconst depth = textures.length || 1;\r\n\t\tthis.setSize( width, height, depth );\r\n\t\trenderer.setClearColor( 0, 0 );\r\n\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t// render each texture into each layer of the target\r\n\t\tconst fsQuad = this.fsQuad;\r\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\r\n\r\n\t\t\tconst texture = textures[ i ];\r\n\t\t\tif ( texture ) {\r\n\r\n\t\t\t\t// revert to default texture transform before rendering\r\n\t\t\t\ttexture.matrixAutoUpdate = false;\r\n\t\t\t\ttexture.matrix.identity();\r\n\r\n\t\t\t\tfsQuad.material.map = texture;\r\n\t\t\t\tfsQuad.material.transparent = true;\r\n\r\n\t\t\t\trenderer.setRenderTarget( this, i );\r\n\t\t\t\tfsQuad.render( renderer );\r\n\r\n\t\t\t\t// restore custom texture transform\r\n\t\t\t\ttexture.updateMatrix();\r\n\t\t\t\ttexture.matrixAutoUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the renderer\r\n\t\tfsQuad.material.map = null;\r\n\t\trenderer.setClearColor( prevColor, prevAlpha );\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.toneMapping = prevToneMapping;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tsuper.dispose();\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping } from 'three';\r\n\r\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\r\n\r\n\tlet lower = 0;\r\n\tlet upper = count;\r\n\twhile ( lower < upper ) {\r\n\r\n\t\tconst mid = ~ ~ ( 0.5 * upper + 0.5 * lower );\r\n\r\n\r\n\t\t// check if the middle array value is above or below the target and shift\r\n\t\t// which half of the array we're looking at\r\n\t\tif ( array[ offset + mid ] < targetValue ) {\r\n\r\n\t\t\tlower = mid + 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tupper = mid;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn lower;\r\n\r\n}\r\n\r\nfunction colorToLuminance( r, g, b ) {\r\n\r\n\t// https://en.wikipedia.org/wiki/Relative_luminance\r\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\r\n\r\n}\r\n\r\n// ensures the data is all floating point values and flipY is false\r\nfunction preprocessEnvMap( envMap ) {\r\n\r\n\tconst map = envMap.clone();\r\n\tmap.source = new Source( { ...map.image } );\r\n\tconst { width, height, data } = map.image;\r\n\r\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\r\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\r\n\tlet newData = data;\r\n\tif ( map.type === HalfFloatType ) {\r\n\r\n\t\tnewData = new Float32Array( data.length );\r\n\t\tfor ( const i in data ) {\r\n\r\n\t\t\tnewData[ i ] = DataUtils.fromHalfFloat( data[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tmap.image.data = newData;\r\n\t\tmap.type = FloatType;\r\n\r\n\t}\r\n\r\n\t// remove any y flipping for cdf computation\r\n\tif ( map.flipY ) {\r\n\r\n\t\tconst ogData = newData;\r\n\t\tnewData = newData.slice();\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst newY = height - y - 1;\r\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\r\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\r\n\r\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\r\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\r\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\r\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.flipY = false;\r\n\t\tmap.image.data = newData;\r\n\r\n\t}\r\n\r\n\treturn map;\r\n\r\n}\r\n\r\nexport class EquirectHdrInfoUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\r\n\t\t// used to sampling a random value to a relevant row to sample from\r\n\t\tconst marginalWeights = new DataTexture();\r\n\t\tmarginalWeights.type = FloatType;\r\n\t\tmarginalWeights.format = RedFormat;\r\n\t\tmarginalWeights.minFilter = LinearFilter;\r\n\t\tmarginalWeights.magFilter = LinearFilter;\r\n\t\tmarginalWeights.generateMipmaps = false;\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\r\n\t\t// used to sampling a random value to a relevant pixel to sample from\r\n\t\tconst conditionalWeights = new DataTexture();\r\n\t\tconditionalWeights.type = FloatType;\r\n\t\tconditionalWeights.format = RedFormat;\r\n\t\tconditionalWeights.minFilter = LinearFilter;\r\n\t\tconditionalWeights.magFilter = LinearFilter;\r\n\t\tconditionalWeights.generateMipmaps = false;\r\n\r\n\t\t// store the total sum in a 1x1 tex since some android mobile devices have issues\r\n\t\t// storing large values in structs.\r\n\t\tconst totalSumTex = new DataTexture();\r\n\t\ttotalSumTex.type = FloatType;\r\n\t\ttotalSumTex.format = RedFormat;\r\n\t\ttotalSumTex.minFilter = LinearFilter;\r\n\t\ttotalSumTex.magFilter = LinearFilter;\r\n\t\ttotalSumTex.generateMipmaps = false;\r\n\r\n\t\tthis.marginalWeights = marginalWeights;\r\n\t\tthis.conditionalWeights = conditionalWeights;\r\n\t\tthis.totalSum = totalSumTex;\r\n\t\tthis.map = null;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.marginalWeights.dispose();\r\n\t\tthis.conditionalWeights.dispose();\r\n\t\tthis.totalSum.dispose();\r\n\t\tif ( this.map ) this.map.dispose();\r\n\r\n\t}\r\n\r\n\tupdateFrom( hdr ) {\r\n\r\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\r\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\r\n\t\tconst map = preprocessEnvMap( hdr );\r\n\t\tmap.wrapS = RepeatWrapping;\r\n\t\tmap.wrapT = RepeatWrapping;\r\n\r\n\t\tconst { width, height, data } = map.image;\r\n\r\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\r\n\t\t// \"marginal\" = \"row relative to row sum\"\r\n\r\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\r\n\t\tconst pdfConditional = new Float32Array( width * height );\r\n\t\tconst cdfConditional = new Float32Array( width * height );\r\n\r\n\t\tconst pdfMarginal = new Float32Array( height );\r\n\t\tconst cdfMarginal = new Float32Array( height );\r\n\r\n\t\tlet totalSumValue = 0.0;\r\n\t\tlet cumulativeWeightMarginal = 0.0;\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tlet cumulativeRowWeight = 0.0;\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst r = data[ 4 * i + 0 ];\r\n\t\t\t\tconst g = data[ 4 * i + 1 ];\r\n\t\t\t\tconst b = data[ 4 * i + 2 ];\r\n\r\n\t\t\t\t// the probability of the pixel being selected in this row is the\r\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\r\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\r\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\r\n\t\t\t\tcumulativeRowWeight += weight;\r\n\t\t\t\ttotalSumValue += weight;\r\n\r\n\t\t\t\tpdfConditional[ i ] = weight;\r\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// can happen if the row is all black\r\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\r\n\r\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\r\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\r\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\r\n\r\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\r\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\r\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\r\n\r\n\t\t}\r\n\r\n\t\t// can happen if the texture is all black\r\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\r\n\r\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\r\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute a sorted index of distributions and the probabilities along them for both\r\n\t\t// the marginal and conditional data. These will be used to sample with a random number\r\n\t\t// to retrieve a uv value to sample in the environment map.\r\n\t\t// These values continually increase so it's okay to interpolate between them.\r\n\t\tconst marginalDataArray = new Float32Array( height );\r\n\t\tconst conditionalDataArray = new Float32Array( width * height );\r\n\r\n\t\tfor ( let i = 0; i < height; i ++ ) {\r\n\r\n\t\t\tconst dist = ( i + 1 ) / height;\r\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\r\n\r\n\t\t\tmarginalDataArray[ i ] = row / height;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst dist = ( x + 1 ) / width;\r\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\r\n\r\n\t\t\t\tconditionalDataArray[ i ] = col / width;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.dispose();\r\n\r\n\t\tconst { marginalWeights, conditionalWeights, totalSum } = this;\r\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\ttotalSum.image = { width: 1, height: 1, data: new Float32Array( [ totalSumValue ] ) };\r\n\t\ttotalSum.needsUpdate = true;\r\n\r\n\t\tthis.map = map;\r\n\r\n\t}\r\n\r\n}\r\n","import { PhysicalCamera } from '../core/PhysicalCamera.js';\r\nexport class PhysicalCameraUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.bokehSize = 0;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 10;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tupdateFrom( camera ) {\r\n\r\n\t\tif ( camera instanceof PhysicalCamera ) {\r\n\r\n\t\t\tthis.bokehSize = camera.bokehSize;\r\n\t\t\tthis.apertureBlades = camera.apertureBlades;\r\n\t\t\tthis.apertureRotation = camera.apertureRotation;\r\n\t\t\tthis.focusDistance = camera.focusDistance;\r\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.bokehSize = 0;\r\n\t\t\tthis.apertureRotation = 0;\r\n\t\t\tthis.apertureBlades = 0;\r\n\t\t\tthis.focusDistance = 10;\r\n\t\t\tthis.anamorphicRatio = 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","export const shaderUtils = /* glsl */`\r\n\r\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\r\n\tfloat schlickFresnel( float cosine, float f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\r\n\tfloat schlickFresnelFromIor( float cosine, float iorRatio ) {\r\n\r\n\t\t// Schlick approximation\r\n\t\tfloat r_0 = pow( ( 1.0 - iorRatio ) / ( 1.0 + iorRatio ), 2.0 );\r\n\t\treturn schlickFresnel( cosine, r_0 );\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\tvec3 getHemisphereSample( vec3 n, vec2 uv ) {\r\n\r\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\r\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\r\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\r\n\t\tfloat a = - 1.0 / ( sign + n.z );\r\n\t\tfloat b = n.x * n.y * a;\r\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\r\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\r\n\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat theta = 2.0 * PI * uv.y;\r\n\t\tfloat x = r * cos( theta );\r\n\t\tfloat y = r * sin( theta );\r\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\r\n\r\n\t}\r\n\r\n\t// https://www.shadertoy.com/view/wltcRS\r\n\tuvec4 s0;\r\n\r\n\tvoid rng_initialize(vec2 p, int frame) {\r\n\r\n\t\t// white noise seed\r\n\t\ts0 = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\r\n\r\n\t}\r\n\r\n\t// https://www.pcg-random.org/\r\n\tvoid pcg4d( inout uvec4 v ) {\r\n\r\n\t\tv = v * 1664525u + 1013904223u;\r\n\t\tv.x += v.y * v.w;\r\n\t\tv.y += v.z * v.x;\r\n\t\tv.z += v.x * v.y;\r\n\t\tv.w += v.y * v.z;\r\n\t\tv = v ^ ( v >> 16u );\r\n\t\tv.x += v.y*v.w;\r\n\t\tv.y += v.z*v.x;\r\n\t\tv.z += v.x*v.y;\r\n\t\tv.w += v.y*v.z;\r\n\r\n\t}\r\n\r\n\t// returns [ 0, 1 ]\r\n\tfloat rand() {\r\n\r\n\t\tpcg4d(s0);\r\n\t\treturn float( s0.x ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec2 rand2() {\r\n\r\n\t\tpcg4d( s0 );\r\n\t\treturn vec2( s0.xy ) / float(0xffffffffu);\r\n\r\n\t}\r\n\r\n\tvec3 rand3() {\r\n\r\n\t\tpcg4d(s0);\r\n\t\treturn vec3( s0.xyz ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec4 rand4() {\r\n\r\n\t\tpcg4d(s0);\r\n\t\treturn vec4(s0)/float(0xffffffffu);\r\n\r\n\t}\r\n\r\n\t// https://github.com/mrdoob/three.js/blob/dev/src/math/Vector3.js#L724\r\n\tvec3 randDirection() {\r\n\r\n\t\tvec2 r = rand2();\r\n\t\tfloat u = ( r.x - 0.5 ) * 2.0;\r\n\t\tfloat t = r.y * PI * 2.0;\r\n\t\tfloat f = sqrt( 1.0 - u * u );\r\n\r\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\r\n\r\n\t}\r\n\r\n\tvec2 triangleSample( vec2 a, vec2 b, vec2 c ) {\r\n\r\n\t\t// get the edges of the triangle and the diagonal across the\r\n\t\t// center of the parallelogram\r\n\t\tvec2 e1 = a - b;\r\n\t\tvec2 e2 = c - b;\r\n\t\tvec2 diag = normalize( e1 + e2 );\r\n\r\n\t\t// pick a random point in the parallelogram\r\n\t\tvec2 r = rand2();\r\n\t\tif ( r.x + r.y > 1.0 ) {\r\n\r\n\t\t\tr = vec2( 1.0 ) - r;\r\n\r\n\t\t}\r\n\r\n\t\treturn e1 * r.x + e2 * r.y;\r\n\r\n\t}\r\n\r\n\t// samples an aperture shape with the given number of sides. 0 means circle\r\n\tvec2 sampleAperture( int blades ) {\r\n\r\n\t\tif ( blades == 0 ) {\r\n\r\n\t\t\tvec2 r = rand2();\r\n\t\t\tfloat angle = 2.0 * PI * r.x;\r\n\t\t\tfloat radius = sqrt( rand() );\r\n\t\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tblades = max( blades, 3 );\r\n\r\n\t\t\tvec3 r = rand3();\r\n\t\t\tfloat anglePerSegment = 2.0 * PI / float( blades );\r\n\t\t\tfloat segment = floor( float( blades ) * r.x );\r\n\r\n\t\t\tfloat angle1 = anglePerSegment * segment;\r\n\t\t\tfloat angle2 = angle1 + anglePerSegment;\r\n\t\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\r\n\t\t\tvec2 b = vec2( 0.0, 0.0 );\r\n\t\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\r\n\r\n\t\t\treturn triangleSample( a, b, c );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfloat colorToLuminance( vec3 color ) {\r\n\r\n\t\t// https://en.wikipedia.org/wiki/Relative_luminance\r\n\t\treturn 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the rectangle on that same plane.\r\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\r\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\r\n\r\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = p - center;\r\n\r\n\t\t\t// check if p falls inside the rectangle\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\r\n\r\n\t\t\t\tfloat a2 = dot( v, vi );\r\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\r\n\r\n\t\t\t\t\tdist = t;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n`;\r\n","import { WebGLRenderTarget, RGBAFormat, FloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { MaterialBase } from '../materials/MaterialBase.js';\r\nimport { shaderUtils } from '../shader/shaderUtils.js';\r\n\r\nclass PMREMCopyMaterial extends MaterialBase {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tenvMap: { value: null },\r\n\t\t\t\tblur: { value: 0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\t\t${ shaderUtils }\r\n\r\n\t\t\t\tuniform sampler2D envMap;\r\n\t\t\t\tuniform float blur;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\r\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class BlurredEnvMapGenerator {\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\r\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\r\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.pmremGenerator.dispose();\r\n\t\tthis.copyQuad.dispose();\r\n\t\tthis.renderTarget.dispose();\r\n\r\n\t}\r\n\r\n\tgenerate( texture, blur ) {\r\n\r\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\r\n\r\n\t\t// get the pmrem target\r\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\r\n\r\n\t\t// set up the material\r\n\t\tconst { width, height } = texture.image;\r\n\t\trenderTarget.setSize( width, height );\r\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\r\n\t\tcopyQuad.material.blur = blur;\r\n\r\n\t\t// render\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevClear = renderer.autoClear;\r\n\r\n\t\trenderer.setRenderTarget( renderTarget );\r\n\t\trenderer.autoClear = true;\r\n\t\tcopyQuad.render( renderer );\r\n\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.autoClear = prevClear;\r\n\r\n\t\t// read the data back\r\n\t\tconst buffer = new Float32Array( width * height * 4 );\r\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );\r\n\r\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, FloatType );\r\n\t\tresult.minFilter = texture.minFilter;\r\n\t\tresult.magFilter = texture.magFilter;\r\n\t\tresult.wrapS = texture.wrapS;\r\n\t\tresult.wrapT = texture.wrapT;\r\n\t\tresult.mapping = EquirectangularReflectionMapping;\r\n\t\tresult.needsUpdate = true;\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n","export const shaderMaterialStructs = /* glsl */ `\r\n\r\n\tstruct PhysicalCamera {\r\n\r\n\t\tfloat focusDistance;\r\n\t\tfloat anamorphicRatio;\r\n\t\tfloat bokehSize;\r\n\t\tint apertureBlades;\r\n\t\tfloat apertureRotation;\r\n\r\n\t};\r\n\r\n\tstruct EquirectHdrInfo {\r\n\r\n\t\tsampler2D marginalWeights;\r\n\t\tsampler2D conditionalWeights;\r\n\t\tsampler2D map;\r\n\t\tsampler2D totalSum;\r\n\r\n\t};\r\n\r\n\tstruct Material {\r\n\r\n\t\tvec3 color;\r\n\t\tint map;\r\n\r\n\t\tfloat metalness;\r\n\t\tint metalnessMap;\r\n\r\n\t\tfloat roughness;\r\n\t\tint roughnessMap;\r\n\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tint transmissionMap;\r\n\r\n\t\tfloat emissiveIntensity;\r\n\t\tvec3 emissive;\r\n\t\tint emissiveMap;\r\n\r\n\t\tint normalMap;\r\n\t\tvec2 normalScale;\r\n\r\n\t\tint alphaMap;\r\n\r\n\t\tbool castShadow;\r\n\t\tfloat opacity;\r\n\t\tfloat alphaTest;\r\n\r\n\t\tfloat side;\r\n\t\tbool matte;\r\n\r\n\t\tmat3 mapTransform;\r\n\t\tmat3 metalnessMapTransform;\r\n\t\tmat3 roughnessMapTransform;\r\n\t\tmat3 transmissionMapTransform;\r\n\t\tmat3 emissiveMapTransform;\r\n\t\tmat3 normalMapTransform;\r\n\r\n\t};\r\n\r\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\r\n\r\n\t\tmat3 textureTransform;\r\n\r\n\t\tvec4 row1 = texelFetch1D( tex, index );\r\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\r\n\r\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\r\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\r\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\r\n\r\n\t\treturn textureTransform;\r\n\r\n\t}\r\n\r\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 19u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\r\n\r\n\t\tMaterial m;\r\n\t\tm.color = s0.rgb;\r\n\t\tm.map = int( round( s0.a ) );\r\n\r\n\t\tm.metalness = s1.r;\r\n\t\tm.metalnessMap = int( round( s1.g ) );\r\n\t\tm.roughness = s1.b;\r\n\t\tm.roughnessMap = int( round( s1.a ) );\r\n\r\n\t\tm.ior = s2.r;\r\n\t\tm.transmission = s2.g;\r\n\t\tm.transmissionMap = int( round( s2.b ) );\r\n\t\tm.emissiveIntensity = s2.a;\r\n\r\n\t\tm.emissive = s3.rgb;\r\n\t\tm.emissiveMap = int( round( s3.a ) );\r\n\r\n\t\tm.normalMap = int( round( s4.r ) );\r\n\t\tm.normalScale = s4.gb;\r\n\r\n\t\tm.alphaMap = int( round( s4.a ) );\r\n\r\n\t\tm.opacity = s5.r;\r\n\t\tm.alphaTest = s5.g;\r\n\t\tm.side = s5.b;\r\n\t\tm.matte = bool( s5.a );\r\n\r\n\t\tm.castShadow = ! bool( s6.r );\r\n\r\n\t\tuint firstTextureTransformIdx = i + 7u;\r\n\r\n\t\tm.mapTransform = m.map == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx);\r\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\r\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\r\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\r\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\r\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\r\n\r\n\t\treturn m;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const shaderLightStruct = /* glsl */ `\r\n\tstruct Light {\r\n\r\n\t\tvec3 position;\r\n\r\n\t\tvec3 color;\r\n\t\tfloat intensity;\r\n\r\n\t\tvec3 u;\r\n\t\tvec3 v;\r\n\t\tfloat area;\r\n\r\n\t};\r\n\r\n\tLight readLightInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 4u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\r\n\t\tLight l;\r\n\t\tl.position = s0.rgb;\r\n\r\n\t\tl.color = s1.rgb;\r\n\t\tl.intensity = s1.a;\r\n\r\n\t\tl.u = s2.rgb;\r\n\t\tl.v = s3.rgb;\r\n\t\tl.area = s3.a;\r\n\r\n\t\treturn l;\r\n\r\n\t}\r\n\r\n`;\r\n","export const shaderGGXFunctions = /* glsl */`\r\n// The GGX functions provide sampling and distribution information for normals as output so\r\n// in order to get probability of scatter direction the half vector must be computed and provided.\r\n// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n// [2] http://jcgt.org/published/0007/04/01/\r\n// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n// trowbridge-reitz === GGX === GTR\r\n\r\nvec3 ggxDirection( vec3 incidentDir, float roughnessX, float roughnessY, float random1, float random2 ) {\r\n\r\n\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t// function below, as well\r\n\r\n\t// Implementation from reference [1]\r\n\t// stretch view\r\n\tvec3 V = normalize( vec3( roughnessX * incidentDir.x, roughnessY * incidentDir.y, incidentDir.z ) );\r\n\r\n\t// orthonormal basis\r\n\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\tvec3 T2 = cross( T1, V );\r\n\r\n\t// sample point with polar coordinates (r, phi)\r\n\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\tfloat r = sqrt( random1 );\r\n\tfloat phi = ( random2 < a ) ? random2 / a * PI : PI + ( random2 - a ) / ( 1.0 - a ) * PI;\r\n\tfloat P1 = r * cos( phi );\r\n\tfloat P2 = r * sin( phi ) * ( ( random2 < a ) ? 1.0 : V.z );\r\n\r\n\t// compute normal\r\n\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t// unstretch\r\n\tN = normalize( vec3( roughnessX * N.x, roughnessY * N.y, max( 0.0, N.z ) ) );\r\n\r\n\treturn N;\r\n\r\n}\r\n\r\n// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n// as specified in Appendix B of the following paper\r\n// See equation (2) from reference [2]\r\nfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\tfloat tanTheta = tan( theta );\r\n\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\tfloat alpha2 = roughness * roughness;\r\n\r\n\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\treturn numerator / 2.0;\r\n\r\n}\r\n\r\n// See equation (2) from reference [2]\r\nfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n}\r\n\r\n// See equation (125) from reference [4]\r\nfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\tfloat incidentTheta = acos( wi.z );\r\n\tfloat scatterTheta = acos( wo.z );\r\n\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n}\r\n\r\nfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat a2 = roughness * roughness;\r\n\ta2 = max( EPSILON, a2 );\r\n\tfloat cosTheta = halfVector.z;\r\n\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\tfloat theta = acosSafe( halfVector.z );\r\n\tfloat tanTheta = tan( theta );\r\n\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\treturn ( a2 / denom );\r\n\r\n\t// See equation (1) from reference [2]\r\n\t// const { x, y, z } = halfVector;\r\n\t// const a2 = roughness * roughness;\r\n\t// const mult = x * x / a2 + y * y / a2 + z * z;\r\n\t// const mult2 = mult * mult;\r\n\r\n\t// return 1.0 / Math.PI * a2 * mult2;\r\n\r\n}\r\n\r\n// See equation (3) from reference [2]\r\nfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\tfloat incidentTheta = acos( wi.z );\r\n\tfloat D = ggxDistribution( halfVector, roughness );\r\n\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n}\r\n`;\r\n","import { shaderGGXFunctions } from './shaderGGXFunctions.js';\r\n\r\nexport const shaderMaterialSampling = /* glsl */`\r\n\r\nstruct SurfaceRec {\r\n\tvec3 normal;\r\n\tvec3 faceNormal;\r\n\tbool frontFace;\r\n\tfloat roughness;\r\n\tfloat filteredRoughness;\r\n\tfloat metalness;\r\n\tvec3 color;\r\n\tvec3 emission;\r\n\tfloat transmission;\r\n\tfloat ior;\r\n};\r\n\r\nstruct SampleRec {\r\n\tfloat specularPdf;\r\n\tfloat pdf;\r\n\tvec3 direction;\r\n\tvec3 color;\r\n};\r\n\r\n${ shaderGGXFunctions }\r\n\r\n// diffuse\r\nfloat diffusePDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\t// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html#lightscattering/thescatteringpdf\r\n\tfloat cosValue = wi.z;\r\n\treturn cosValue / PI;\r\n\r\n}\r\n\r\nvec3 diffuseDirection( vec3 wo, SurfaceRec surf ) {\r\n\r\n\tvec3 lightDirection = randDirection();\r\n\tlightDirection.z += 1.0;\r\n\tlightDirection = normalize( lightDirection );\r\n\r\n\treturn lightDirection;\r\n\r\n}\r\n\r\nvec3 diffuseColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\t// TODO: scale by 1 - F here\r\n\t// note on division by PI\r\n\t// https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\r\n\tfloat metalFactor = ( 1.0 - surf.metalness ) * wi.z / ( PI * PI );\r\n\tfloat transmissionFactor = 1.0 - surf.transmission;\r\n\treturn surf.color * metalFactor * transmissionFactor;\r\n\r\n}\r\n\r\n// specular\r\nfloat specularPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\t// See equation (27) in http://jcgt.org/published/0003/02/03/\r\n\tfloat filteredRoughness = surf.filteredRoughness;\r\n\tvec3 halfVector = getHalfVector( wi, wo );\r\n\treturn ggxPDF( wo, halfVector, filteredRoughness ) / ( 4.0 * dot( wi, halfVector ) );\r\n\r\n}\r\n\r\nvec3 specularDirection( vec3 wo, SurfaceRec surf ) {\r\n\r\n\t// sample ggx vndf distribution which gives a new normal\r\n\tfloat filteredRoughness = surf.filteredRoughness;\r\n\tvec3 halfVector = ggxDirection(\r\n\t\two,\r\n\t\tfilteredRoughness,\r\n\t\tfilteredRoughness,\r\n\t\trand(),\r\n\t\trand()\r\n\t);\r\n\r\n\t// apply to new ray by reflecting off the new normal\r\n\treturn - reflect( wo, halfVector );\r\n\r\n}\r\n\r\nvec3 specularColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\t// if roughness is set to 0 then D === NaN which results in black pixels\r\n\tfloat metalness = surf.metalness;\r\n\tfloat ior = surf.ior;\r\n\tbool frontFace = surf.frontFace;\r\n\tfloat filteredRoughness = surf.filteredRoughness;\r\n\r\n\tvec3 halfVector = getHalfVector( wo, wi );\r\n\tfloat iorRatio = frontFace ? 1.0 / ior : ior;\r\n\tfloat G = ggxShadowMaskG2( wi, wo, filteredRoughness );\r\n\tfloat D = ggxDistribution( halfVector, filteredRoughness );\r\n\r\n\tfloat F = schlickFresnelFromIor( dot( wi, halfVector ), iorRatio );\r\n\tfloat cosTheta = min( wo.z, 1.0 );\r\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\tbool cannotRefract = iorRatio * sinTheta > 1.0;\r\n\tif ( cannotRefract ) {\r\n\r\n\t\tF = 1.0;\r\n\r\n\t}\r\n\r\n\tvec3 color = mix( vec3( 1.0 ), surf.color, metalness );\r\n\tcolor = mix( color, vec3( 1.0 ), F );\r\n\tcolor *= G * D / ( 4.0 * abs( wi.z * wo.z ) );\r\n\tcolor *= mix( F, 1.0, metalness );\r\n\tcolor *= wi.z; // scale the light by the direction the light is coming in from\r\n\r\n\treturn color;\r\n\r\n}\r\n\r\n/*\r\n// transmission\r\nfunction transmissionPDF( wo, wi, material, surf ) {\r\n\r\n\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\r\n\tconst { roughness, ior } = material;\r\n\tconst { frontFace } = hit;\r\n\tconst ratio = frontFace ? ior : 1 / ior;\r\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\r\n\r\n\thalfVector.set( 0, 0, 0 ).addScaledVector( wi, ratio ).addScaledVector( wo, 1.0 ).normalize().multiplyScalar( - 1 );\r\n\r\n\tconst denom = Math.pow( ratio * halfVector.dot( wi ) + 1.0 * halfVector.dot( wo ), 2.0 );\r\n\treturn ggxPDF( wo, halfVector, minRoughness ) / denom;\r\n\r\n}\r\n\r\nfunction transmissionDirection( wo, hit, material, lightDirection ) {\r\n\r\n\tconst { roughness, ior } = material;\r\n\tconst { frontFace } = hit;\r\n\tconst ratio = frontFace ? 1 / ior : ior;\r\n\tconst minRoughness = Math.max( roughness, MIN_ROUGHNESS );\r\n\r\n\t// sample ggx vndf distribution which gives a new normal\r\n\tggxDirection(\r\n\t\two,\r\n\t\tminRoughness,\r\n\t\tminRoughness,\r\n\t\tMath.random(),\r\n\t\tMath.random(),\r\n\t\thalfVector,\r\n\t);\r\n\r\n\t// apply to new ray by reflecting off the new normal\r\n\ttempDir.copy( wo ).multiplyScalar( - 1 );\r\n\trefract( tempDir, halfVector, ratio, lightDirection );\r\n\r\n}\r\n\r\nfunction transmissionColor( wo, wi, material, hit, colorTarget ) {\r\n\r\n\tconst { metalness, transmission } = material;\r\n\tcolorTarget\r\n\t\t.copy( material.color )\r\n\t\t.multiplyScalar( ( 1.0 - metalness ) * wo.z )\r\n\t\t.multiplyScalar( transmission );\r\n\r\n}\r\n*/\r\n\r\n// TODO: This is just using a basic cosine-weighted specular distribution with an\r\n// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\r\nfloat transmissionPDF( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\tfloat ior = surf.ior;\r\n\tbool frontFace = surf.frontFace;\r\n\r\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\r\n\tfloat cosTheta = min( wo.z, 1.0 );\r\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\r\n\tbool cannotRefract = ratio * sinTheta > 1.0;\r\n\tif ( cannotRefract ) {\r\n\r\n\t\treturn 0.0;\r\n\r\n\t}\r\n\r\n\treturn 1.0 / ( 1.0 - reflectance );\r\n\r\n}\r\n\r\nvec3 transmissionDirection( vec3 wo, SurfaceRec surf ) {\r\n\r\n\tfloat roughness = surf.roughness;\r\n\tfloat ior = surf.ior;\r\n\tbool frontFace = surf.frontFace;\r\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\r\n\r\n\tvec3 lightDirection = refract( - wo, vec3( 0.0, 0.0, 1.0 ), ratio );\r\n\tlightDirection += randDirection() * roughness;\r\n\treturn normalize( lightDirection );\r\n\r\n}\r\n\r\nvec3 transmissionColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\tfloat metalness = surf.metalness;\r\n\tfloat transmission = surf.transmission;\r\n\r\n\tvec3 color = surf.color;\r\n\tcolor *= ( 1.0 - metalness );\r\n\tcolor *= transmission;\r\n\r\n\treturn color;\r\n\r\n}\r\n\r\nfloat bsdfPdf( vec3 wo, vec3 wi, SurfaceRec surf, out float specularPdf ) {\r\n\r\n\tfloat ior = surf.ior;\r\n\tfloat metalness = surf.metalness;\r\n\tfloat transmission = surf.transmission;\r\n\tbool frontFace = surf.frontFace;\r\n\r\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\r\n\tfloat cosTheta = min( wo.z, 1.0 );\r\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\r\n\tbool cannotRefract = ratio * sinTheta > 1.0;\r\n\tif ( cannotRefract ) {\r\n\r\n\t\treflectance = 1.0;\r\n\r\n\t}\r\n\r\n\tfloat spdf = 0.0;\r\n\tfloat dpdf = 0.0;\r\n\tfloat tpdf = 0.0;\r\n\r\n\tif ( wi.z < 0.0 ) {\r\n\r\n\t\ttpdf = transmissionPDF( wo, wi, surf );\r\n\r\n\t} else {\r\n\r\n\t\tspdf = specularPDF( wo, wi, surf );\r\n\t\tdpdf = diffusePDF( wo, wi, surf );\r\n\r\n\t}\r\n\r\n\tfloat transSpecularProb = mix( reflectance, 1.0, metalness );\r\n\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\r\n\tfloat pdf =\r\n\t\tspdf * transmission * transSpecularProb\r\n\t\t+ tpdf * transmission * ( 1.0 - transSpecularProb )\r\n\t\t+ spdf * ( 1.0 - transmission ) * diffSpecularProb\r\n\t\t+ dpdf * ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\r\n\r\n\t// retrieve specular rays for the shadows flag\r\n\tspecularPdf = spdf * transmission * transSpecularProb + spdf * ( 1.0 - transmission ) * diffSpecularProb;\r\n\r\n\treturn pdf;\r\n\r\n}\r\n\r\nvec3 bsdfColor( vec3 wo, vec3 wi, SurfaceRec surf ) {\r\n\r\n\tvec3 color = vec3( 0.0 );\r\n\tif ( wi.z < 0.0 ) {\r\n\r\n\t\tcolor = transmissionColor( wo, wi, surf );\r\n\r\n\t} else {\r\n\r\n\t\tcolor = diffuseColor( wo, wi, surf );\r\n\t\tcolor *= 1.0 - surf.transmission;\r\n\r\n\t\tcolor += specularColor( wo, wi, surf );\r\n\r\n\t}\r\n\r\n\treturn color;\r\n\r\n}\r\n\r\nfloat bsdfResult( vec3 wo, vec3 wi, SurfaceRec surf, out vec3 color ) {\r\n\r\n\tfloat specularPdf;\r\n\tcolor = bsdfColor( wo, wi, surf );\r\n\treturn bsdfPdf( wo, wi, surf, specularPdf );\r\n\r\n}\r\n\r\nSampleRec bsdfSample( vec3 wo, SurfaceRec surf ) {\r\n\r\n\tfloat ior = surf.ior;\r\n\tfloat metalness = surf.metalness;\r\n\tfloat transmission = surf.transmission;\r\n\tbool frontFace = surf.frontFace;\r\n\r\n\tfloat ratio = frontFace ? 1.0 / ior : ior;\r\n\tfloat cosTheta = min( wo.z, 1.0 );\r\n\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\tfloat reflectance = schlickFresnelFromIor( cosTheta, ratio );\r\n\tbool cannotRefract = ratio * sinTheta > 1.0;\r\n\tif ( cannotRefract ) {\r\n\r\n\t\treflectance = 1.0;\r\n\r\n\t}\r\n\r\n\tSampleRec result;\r\n\tif ( rand() < transmission ) {\r\n\r\n\t\tfloat specularProb = mix( reflectance, 1.0, metalness );\r\n\t\tif ( rand() < specularProb ) {\r\n\r\n\t\t\tresult.direction = specularDirection( wo, surf );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.direction = transmissionDirection( wo, surf );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tfloat specularProb = 0.5 + 0.5 * metalness;\r\n\t\tif ( rand() < specularProb ) {\r\n\r\n\t\t\tresult.direction = specularDirection( wo, surf );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.direction = diffuseDirection( wo, surf );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.pdf = bsdfPdf( wo, result.direction, surf, result.specularPdf );\r\n\tresult.color = bsdfColor( wo, result.direction, surf );\r\n\treturn result;\r\n\r\n}\r\n`;\r\n","export const shaderEnvMapSampling = /* glsl */`\r\n\r\nvec3 sampleEquirectEnvMapColor( vec3 direction, sampler2D map ) {\r\n\r\n\treturn texture2D( map, equirectDirectionToUv( direction ) ).rgb;\r\n\r\n}\r\n\r\nfloat envMapDirectionPdf( vec3 direction ) {\r\n\r\n\tvec2 uv = equirectDirectionToUv( direction );\r\n\tfloat theta = uv.y * PI;\r\n\tfloat sinTheta = sin( theta );\r\n\tif ( sinTheta == 0.0 ) {\r\n\r\n\t\treturn 0.0;\r\n\r\n\t}\r\n\r\n\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\r\n\r\n}\r\n\r\nfloat envMapSample( vec3 direction, EquirectHdrInfo info, out vec3 color ) {\r\n\r\n\tvec2 uv = equirectDirectionToUv( direction );\r\n\tcolor = texture2D( info.map, uv ).rgb;\r\n\r\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\r\n\tfloat lum = colorToLuminance( color );\r\n\tivec2 resolution = textureSize( info.map, 0 );\r\n\tfloat pdf = lum / totalSum;\r\n\r\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\r\n\r\n}\r\n\r\nfloat randomEnvMapSample( EquirectHdrInfo info, out vec3 color, out vec3 direction ) {\r\n\r\n\t// sample env map cdf\r\n\tvec2 r = rand2();\r\n\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\r\n\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\r\n\tvec2 uv = vec2( u, v );\r\n\r\n\tvec3 derivedDirection = equirectUvToDirection( uv );\r\n\tdirection = derivedDirection;\r\n\tcolor = texture2D( info.map, uv ).rgb;\r\n\r\n\tfloat totalSum = texture2D( info.totalSum, vec2( 0.0 ) ).r;\r\n\tfloat lum = colorToLuminance( color );\r\n\tivec2 resolution = textureSize( info.map, 0 );\r\n\tfloat pdf = lum / totalSum;\r\n\r\n\treturn float( resolution.x * resolution.y ) * pdf * envMapDirectionPdf( direction );\r\n\r\n}\r\n\r\n`;\r\n","export const shaderLightSampling = /* glsl */`\r\n\r\nstruct LightSampleRec {\r\n\tbool hit;\r\n\tfloat dist;\r\n\tvec3 direction;\r\n\tfloat pdf;\r\n\tvec3 emission;\r\n};\r\n\r\nLightSampleRec lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection ) {\r\n\r\n\tLightSampleRec lightSampleRec;\r\n\tlightSampleRec.hit = false;\r\n\r\n\tuint l;\r\n\tfor ( l = 0u; l < lightCount; l++ ) {\r\n\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\r\n\t\t// check for backface\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tu *= 1.0 / dot(u, u);\r\n\t\tv *= 1.0 / dot(v, v);\r\n\r\n\t\tfloat dist;\r\n\t\tif ( intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) {\r\n\r\n\t\t\tif ( dist < lightSampleRec.dist || !lightSampleRec.hit ) {\r\n\r\n\t\t\t\tlightSampleRec.hit = true;\r\n\t\t\t\tlightSampleRec.dist = dist;\r\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\r\n\t\t\t\tlightSampleRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\r\n\t\t\t\tlightSampleRec.emission = light.color * light.intensity;\r\n\t\t\t\tlightSampleRec.direction = rayDirection;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn lightSampleRec;\r\n\r\n}\r\n\r\nLightSampleRec randomRectAreaLightSample( Light light, vec3 rayOrigin ) {\r\n\r\n\tLightSampleRec lightSampleRec;\r\n\tlightSampleRec.hit = true;\r\n\r\n\tlightSampleRec.emission = light.color * light.intensity;\r\n\r\n\tvec3 randomPos = light.position + light.u * ( rand() - 0.5 ) + light.v * ( rand() - 0.5 );\r\n\tvec3 toLight = randomPos - rayOrigin;\r\n\tfloat lightDistSq = dot( toLight, toLight );\r\n\tlightSampleRec.dist = length( toLight );\r\n\r\n\tvec3 direction = normalize( toLight );\r\n\tlightSampleRec.direction = direction;\r\n\r\n\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\r\n\tlightSampleRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\r\n\r\n\treturn lightSampleRec;\r\n\r\n}\r\n\r\nLightSampleRec randomLightSample( sampler2D lights, uint lightCount, vec3 rayOrigin ) {\r\n\r\n\t// pick a random light\r\n\tuint l = uint( rand() * float( lightCount ) );\r\n\tLight light = readLightInfo( lights, l );\r\n\r\n\t// sample the light\r\n\treturn randomRectAreaLightSample( light, rayOrigin );\r\n\r\n}\r\n\r\n`;\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion } from 'three';\r\n\r\nconst LIGHT_PIXELS = 4;\r\n\r\nexport class LightsTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\r\n\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.type = FloatType;\r\n\t\tthis.wrapS = ClampToEdgeWrapping;\r\n\t\tthis.wrapT = ClampToEdgeWrapping;\r\n\t\tthis.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\tupdateFrom( lights ) {\r\n\r\n\t\tlet index = 0;\r\n\t\tconst pixelCount = lights.length * LIGHT_PIXELS;\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\r\n\r\n\t\tif ( this.image.width !== dimension ) {\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t\tthis.image.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\tthis.image.width = dimension;\r\n\t\t\tthis.image.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = this.image.data;\r\n\r\n\t\tconst u = new Vector3();\r\n\t\tconst v = new Vector3();\r\n\t\tconst worldQuaternion = new Quaternion();\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst l = lights[ i ];\r\n\r\n\t\t\t// position\r\n\t\t\tl.getWorldPosition( v );\r\n\t\t\tfloatArray[ index ++ ] = v.x;\r\n\t\t\tfloatArray[ index ++ ] = v.y;\r\n\t\t\tfloatArray[ index ++ ] = v.z;\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// color\r\n\t\t\tfloatArray[ index ++ ] = l.color.r;\r\n\t\t\tfloatArray[ index ++ ] = l.color.g;\r\n\t\t\tfloatArray[ index ++ ] = l.color.b;\r\n\r\n\t\t\t// intensity\r\n\t\t\tfloatArray[ index ++ ] = l.intensity;\r\n\r\n\t\t\t// u vector\r\n\t\t\tl.getWorldQuaternion( worldQuaternion );\r\n\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\t\t\tfloatArray[ index ++ ] = u.x;\r\n\t\t\tfloatArray[ index ++ ] = u.y;\r\n\t\t\tfloatArray[ index ++ ] = u.z;\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// v vector\r\n\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\r\n\t\t\tfloatArray[ index ++ ] = v.x;\r\n\t\t\tfloatArray[ index ++ ] = v.y;\r\n\t\t\tfloatArray[ index ++ ] = v.z;\r\n\r\n\t\t\t// area\r\n\t\t\tfloatArray[ index ++ ] = u.cross( v ).length();\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n","import { Matrix4, Matrix3, Color, Vector2 } from 'three';\r\nimport { MaterialBase } from './MaterialBase.js';\r\nimport {\r\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\r\n\tshaderStructs, shaderIntersectFunction,\r\n} from 'three-mesh-bvh';\r\nimport { shaderMaterialStructs, shaderLightStruct } from '../shader/shaderStructs.js';\r\nimport { MaterialsTexture } from '../uniforms/MaterialsTexture.js';\r\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\r\nimport { shaderMaterialSampling } from '../shader/shaderMaterialSampling.js';\r\nimport { shaderEnvMapSampling } from '../shader/shaderEnvMapSampling.js';\r\nimport { shaderLightSampling } from '../shader/shaderLightSampling.js';\r\nimport { shaderUtils } from '../shader/shaderUtils.js';\r\nimport { PhysicalCameraUniform } from '../uniforms/PhysicalCameraUniform.js';\r\nimport { EquirectHdrInfoUniform } from '../uniforms/EquirectHdrInfoUniform.js';\r\nimport { LightsTexture } from '../uniforms/LightsTexture.js';\r\n\r\nexport class PhysicalPathTracingMaterial extends MaterialBase {\r\n\r\n\tonBeforeRender() {\r\n\r\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\r\n\r\n\t}\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthWrite: false,\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\tFEATURE_MIS: 1,\r\n\t\t\t\tFEATURE_DOF: 1,\r\n\t\t\t\tFEATURE_GRADIENT_BG: 0,\r\n\t\t\t\tTRANSPARENT_TRAVERSALS: 5,\r\n\t\t\t\tCAMERA_TYPE: 0,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\r\n\t\t\t\tbounces: { value: 3 },\r\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\r\n\r\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\r\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\r\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\r\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\r\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\r\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\r\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\r\n\t\t\t\tlights: { value: new LightsTexture() },\r\n\t\t\t\tlightCount: { value: 0 },\r\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\r\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\r\n\t\t\t\tbackgroundBlur: { value: 0.0 },\r\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\r\n\t\t\t\tenvironmentRotation: { value: new Matrix3() },\r\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\r\n\r\n\t\t\t\tseed: { value: 0 },\r\n\t\t\t\topacity: { value: 1 },\r\n\t\t\t\tfilterGlossyFactor: { value: 0.0 },\r\n\r\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\r\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\r\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\r\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define RAY_OFFSET 1e-4\r\n\r\n\t\t\t\tprecision highp isampler2D;\r\n\t\t\t\tprecision highp usampler2D;\r\n\t\t\t\tprecision highp sampler2DArray;\r\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\t${ shaderStructs }\r\n\t\t\t\t${ shaderIntersectFunction }\r\n\t\t\t\t${ shaderMaterialStructs }\r\n\t\t\t\t${ shaderLightStruct }\r\n\r\n\t\t\t\t${ shaderUtils }\r\n\t\t\t\t${ shaderMaterialSampling }\r\n\t\t\t\t${ shaderEnvMapSampling }\r\n\t\t\t\t${ shaderLightSampling }\r\n\r\n\t\t\t\tuniform mat3 environmentRotation;\r\n\t\t\t\tuniform float backgroundBlur;\r\n\t\t\t\tuniform float backgroundAlpha;\r\n\r\n\t\t\t\t#if FEATURE_GRADIENT_BG\r\n\r\n\t\t\t\tuniform vec3 bgGradientTop;\r\n\t\t\t\tuniform vec3 bgGradientBottom;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t#if FEATURE_DOF\r\n\r\n\t\t\t\tuniform PhysicalCamera physicalCamera;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tuniform int bounces;\r\n\t\t\t\tuniform mat4 cameraWorldMatrix;\r\n\t\t\t\tuniform mat4 invProjectionMatrix;\r\n\t\t\t\tuniform sampler2D normalAttribute;\r\n\t\t\t\tuniform sampler2D tangentAttribute;\r\n\t\t\t\tuniform sampler2D uvAttribute;\r\n\t\t\t\tuniform usampler2D materialIndexAttribute;\r\n\t\t\t\tuniform BVH bvh;\r\n\t\t\t\tuniform float environmentIntensity;\r\n\t\t\t\tuniform float filterGlossyFactor;\r\n\t\t\t\tuniform int seed;\r\n\t\t\t\tuniform float opacity;\r\n\t\t\t\tuniform sampler2D materials;\r\n\t\t\t\tuniform sampler2D lights;\r\n\t\t\t\tuniform uint lightCount;\r\n\r\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\r\n\r\n\t\t\t\tuniform sampler2DArray textures;\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvec3 sampleBackground( vec3 direction ) {\r\n\r\n\t\t\t\t\t#if FEATURE_GRADIENT_BG\r\n\r\n\t\t\t\t\tdirection = normalize( direction + randDirection() * 0.05 );\r\n\r\n\t\t\t\t\tfloat value = ( direction.y + 1.0 ) / 2.0;\r\n\t\t\t\t\tvalue = pow( value, 2.0 );\r\n\r\n\t\t\t\t\treturn mix( bgGradientBottom, bgGradientTop, value );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\tvec3 sampleDir = normalize( direction + getHemisphereSample( direction, rand2() ) * 0.5 * backgroundBlur );\r\n\t\t\t\t\treturn environmentIntensity * sampleEquirectEnvMapColor( sampleDir, envMapInfo.map );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\r\n\t\t\t\tbool attenuateHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, int traversals, bool isShadowRay, out vec3 color ) {\r\n\r\n\t\t\t\t\t// hit results\r\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\t\t\t\tfloat side = 1.0;\r\n\t\t\t\t\tfloat dist = 0.0;\r\n\r\n\t\t\t\t\tcolor = vec3( 1.0 );\r\n\r\n\t\t\t\t\tfor ( int i = 0; i < traversals; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\r\n\r\n\t\t\t\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\r\n\t\t\t\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\r\n\t\t\t\t\t\t\t// TODO: should we account for emissive surfaces here?\r\n\r\n\t\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\r\n\t\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\t\t// adjust the ray to the new surface\r\n\t\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\r\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\r\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\r\n\r\n\t\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Opacity Test\r\n\r\n\t\t\t\t\t\t\t// albedo\r\n\t\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// alphaMap\r\n\t\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\r\n\r\n\t\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// transmission\r\n\t\t\t\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// metalness\r\n\t\t\t\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\ttransmissionFactor < rand() && ! (\r\n\t\t\t\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\t\t\t\tmaterial.side != 0.0 && side == material.side\r\n\r\n\t\t\t\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// only attenuate on the way in\r\n\t\t\t\t\t\t\tif ( isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// returns whether the ray hit anything before a certain distance, not just the first surface. Could be optimized to not check the full hierarchy.\r\n\t\t\t\tbool anyCloserHit( BVH bvh, vec3 rayOrigin, vec3 rayDirection, float maxDist ) {\r\n\r\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\t\t\t\tfloat side = 1.0;\r\n\t\t\t\t\tfloat dist = 0.0;\r\n\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\t\t\t\t\treturn hit && dist < maxDist;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t\t\t\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\t\t\t\tfloat tentFilter( float x ) {\r\n\r\n\t\t\t\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3 ndcToRayOrigin( vec2 coord ) {\r\n\r\n\t\t\t\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\r\n\t\t\t\t\treturn rayOrigin4.xyz / rayOrigin4.w;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\r\n\r\n\t\t\t\t\t// get [-1, 1] normalized device coordinates\r\n\t\t\t\t\tvec2 ndc = 2.0 * vUv - vec2( 1.0 );\r\n\r\n\t\t\t\t\tvec3 ss00 = ndcToRayOrigin( vec2( - 1.0, - 1.0 ) );\r\n\t\t\t\t\tvec3 ss01 = ndcToRayOrigin( vec2( - 1.0, 1.0 ) );\r\n\t\t\t\t\tvec3 ss10 = ndcToRayOrigin( vec2( 1.0, - 1.0 ) );\r\n\r\n\t\t\t\t\tvec3 ssdX = ( ss10 - ss00 ) / resolution.x;\r\n\t\t\t\t\tvec3 ssdY = ( ss01 - ss00 ) / resolution.y;\r\n\r\n\t\t\t\t\t// Jitter the camera ray by finding a new subpixel point to point to from the camera origin\r\n\t\t\t\t\t// This is better than just jittering the camera position since it actually results in divergent\r\n\t\t\t\t\t// rays providing better coverage for the pixel\r\n\t\t\t\t\tvec3 rayOrigin = ndcToRayOrigin( ndc ) + tentFilter( rand() ) * ssdX + tentFilter( rand() ) * ssdY;\r\n\r\n\t\t\t\t\tvec3 rayDirection;\r\n\r\n\t\t\t\t\t#if CAMERA_TYPE == 1\r\n\r\n\t\t\t\t\t\t// orthographic\r\n\t\t\t\t\t\trayDirection = ( cameraWorldMatrix * vec4( 0.0, 0.0, -1.0, 0.0 ) ).xyz;\r\n\t\t\t\t\t\trayDirection = normalize( rayDirection );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t// perspective\r\n\t\t\t\t\t\tvec3 cameraOrigin = ( cameraWorldMatrix * vec4( 0.0, 0.0, 0.0, 1.0 ) ).xyz;\r\n\t\t\t\t\t\trayDirection = normalize( rayOrigin - cameraOrigin );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t#if FEATURE_DOF\r\n\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t// depth of field\r\n\t\t\t\t\t\tvec3 focalPoint = rayOrigin + normalize( rayDirection ) * physicalCamera.focusDistance;\r\n\r\n\t\t\t\t\t\t// get the aperture sample\r\n\t\t\t\t\t\tvec2 apertureSample = sampleAperture( physicalCamera.apertureBlades ) * physicalCamera.bokehSize * 0.5 * 1e-3;\r\n\r\n\t\t\t\t\t\t// rotate the aperture shape\r\n\t\t\t\t\t\tfloat ac = cos( physicalCamera.apertureRotation );\r\n\t\t\t\t\t\tfloat as = sin( physicalCamera.apertureRotation );\r\n\t\t\t\t\t\tapertureSample = vec2(\r\n\t\t\t\t\t\t\tapertureSample.x * ac - apertureSample.y * as,\r\n\t\t\t\t\t\t\tapertureSample.x * as + apertureSample.y * ac\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tapertureSample.x *= saturate( physicalCamera.anamorphicRatio );\r\n\t\t\t\t\t\tapertureSample.y *= saturate( 1.0 / physicalCamera.anamorphicRatio );\r\n\r\n\t\t\t\t\t\t// create the new ray\r\n\t\t\t\t\t\trayOrigin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\r\n\t\t\t\t\t\trayDirection = focalPoint - rayOrigin;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\trayDirection = normalize( rayDirection );\r\n\r\n\t\t\t\t\t// inverse environment rotation\r\n\t\t\t\t\tmat3 invEnvironmentRotation = inverse( environmentRotation );\r\n\r\n\t\t\t\t\t// final color\r\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t\t\t// hit results\r\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\t\t\t\tfloat side = 1.0;\r\n\t\t\t\t\tfloat dist = 0.0;\r\n\r\n\t\t\t\t\t// path tracing state\r\n\t\t\t\t\tfloat accumulatedRoughness = 0.0;\r\n\t\t\t\t\tbool transmissiveRay = true;\r\n\t\t\t\t\tint transparentTraversals = TRANSPARENT_TRAVERSALS;\r\n\t\t\t\t\tvec3 throughputColor = vec3( 1.0 );\r\n\t\t\t\t\tSampleRec sampleRec;\r\n\t\t\t\t\tint i;\r\n\t\t\t\t\tbool isShadowRay = false;\r\n\r\n\t\t\t\t\tfor ( i = 0; i < bounces; i ++ ) {\r\n\r\n\t\t\t\t\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\r\n\t\t\t\t\t\tLightSampleRec lightHit = lightsClosestHit( lights, lightCount, rayOrigin, rayDirection );\r\n\r\n\t\t\t\t\t\tif ( lightHit.hit && ( lightHit.dist < dist || !hit ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, lightHit.pdf / float( lightCount + 1u ) );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightHit.emission * throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tlightHit.emission *\r\n\t\t\t\t\t\t\t\t\tthroughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! hit ) {\r\n\r\n\t\t\t\t\t\t\tif ( i == 0 || transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( environmentRotation * rayDirection ) * throughputColor;\r\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\r\n\t\t\t\t\t\t\t\tvec3 envColor;\r\n\t\t\t\t\t\t\t\tfloat envPdf = envMapSample( environmentRotation * rayDirection, envMapInfo, envColor );\r\n\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\r\n\r\n\t\t\t\t\t\t\t\t// and weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( sampleRec.pdf, envPdf );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\r\n\t\t\t\t\t\t\t\t\tsampleEquirectEnvMapColor( environmentRotation * rayDirection, envMapInfo.map ) *\r\n\t\t\t\t\t\t\t\t\tthroughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\tif ( material.matte && i == 0 ) {\r\n\r\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\r\n\t\t\t\t\t\t// then skip it\r\n\t\t\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\r\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\r\n\t\t\t\t\t\t// albedo\r\n\t\t\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// alphaMap\r\n\t\t\t\t\t\tif ( material.alphaMap != -1 ) {\r\n\r\n\t\t\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\r\n\t\t\t\t\t\t// and it's single sided.\r\n\t\t\t\t\t\t// - alpha test is disabled when it === 0\r\n\t\t\t\t\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\r\n\t\t\t\t\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\r\n\t\t\t\t\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\r\n\t\t\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\t\t\tbool isFirstHit = i == 0;\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\t\tmaterial.side != 0.0 && ( side != material.side ) == isFirstHit\r\n\r\n\t\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t\t|| ! useAlphaTest && albedo.a < rand()\r\n\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\t\t\t\t\t\tvec3 absPoint = abs( point );\r\n\t\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\t\t\t\t\t\trayOrigin = point - ( maxPoint + 1.0 ) * faceNormal * RAY_OFFSET;\r\n\r\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\r\n\t\t\t\t\t\t\t// crash the context with too long a loop.\r\n\t\t\t\t\t\t\ti -= sign( transparentTraversals );\r\n\t\t\t\t\t\t\ttransparentTraversals -= sign( transparentTraversals );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// fetch the interpolated smooth normal\r\n\t\t\t\t\t\tvec3 normal = normalize( textureSampleBarycoord(\r\n\t\t\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\t\t\tbarycoord,\r\n\t\t\t\t\t\t\tfaceIndices.xyz\r\n\t\t\t\t\t\t).xyz );\r\n\r\n\t\t\t\t\t\t// roughness\r\n\t\t\t\t\t\tfloat roughness = material.roughness;\r\n\t\t\t\t\t\tif ( material.roughnessMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// metalness\r\n\t\t\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// emission\r\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\r\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// transmission\r\n\t\t\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// normal\r\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\r\n\r\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\t\t\t\t\ttangentAttribute,\r\n\t\t\t\t\t\t\t\tbarycoord,\r\n\t\t\t\t\t\t\t\tfaceIndices.xyz\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\r\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\r\n\r\n\t\t\t\t\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\r\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnormal *= side;\r\n\r\n\t\t\t\t\t\tSurfaceRec surfaceRec;\r\n\t\t\t\t\t\tsurfaceRec.normal = normal;\r\n\t\t\t\t\t\tsurfaceRec.faceNormal = faceNormal;\r\n\t\t\t\t\t\tsurfaceRec.transmission = transmission;\r\n\t\t\t\t\t\tsurfaceRec.ior = material.ior;\r\n\t\t\t\t\t\tsurfaceRec.emission = emission;\r\n\t\t\t\t\t\tsurfaceRec.metalness = metalness;\r\n\t\t\t\t\t\tsurfaceRec.color = albedo.rgb;\r\n\t\t\t\t\t\tsurfaceRec.roughness = roughness;\r\n\r\n\t\t\t\t\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\r\n\t\t\t\t\t\t// then we can just always assume this is a front face.\r\n\t\t\t\t\t\tsurfaceRec.frontFace = side == 1.0 || transmission == 0.0;\r\n\r\n\t\t\t\t\t\t// Compute the filtered roughness value to use during specular reflection computations.\r\n\t\t\t\t\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\r\n\t\t\t\t\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\r\n\t\t\t\t\t\t// sharp internal reflections\r\n\t\t\t\t\t\tsurfaceRec.filteredRoughness = clamp( max( surfaceRec.roughness, accumulatedRoughness * filterGlossyFactor * 5.0 ), 0.0, 1.0 );\r\n\r\n\t\t\t\t\t\tmat3 normalBasis = getBasisFromNormal( surfaceRec.normal );\r\n\t\t\t\t\t\tmat3 invBasis = inverse( normalBasis );\r\n\r\n\t\t\t\t\t\tvec3 outgoing = - normalize( invBasis * rayDirection );\r\n\t\t\t\t\t\tsampleRec = bsdfSample( outgoing, surfaceRec );\r\n\r\n\t\t\t\t\t\tisShadowRay = sampleRec.specularPdf < rand();\r\n\r\n\t\t\t\t\t\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t\t\t\t\t\t// maximum component-wise value of the current point to accommodate floating point\r\n\t\t\t\t\t\t// error as values increase.\r\n\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\t\t\t\t\tvec3 absPoint = abs( point );\r\n\t\t\t\t\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\t\t\t\t\trayDirection = normalize( normalBasis * sampleRec.direction );\r\n\r\n\t\t\t\t\t\tbool isBelowSurface = dot( rayDirection, faceNormal ) < 0.0;\r\n\t\t\t\t\t\trayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * ( isBelowSurface ? - RAY_OFFSET : RAY_OFFSET );\r\n\r\n\t\t\t\t\t\t// direct env map sampling\r\n\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t// uniformly pick a light or environment map\r\n\t\t\t\t\t\tif( rand() > 1.0 / float( lightCount + 1u ) ) {\r\n\r\n\t\t\t\t\t\t\t// sample a light or environment\r\n\t\t\t\t\t\t\tLightSampleRec lightSampleRec = randomLightSample( lights, lightCount, rayOrigin );\r\n\r\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, lightSampleRec.direction ) < 0.0;\r\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t\tlightSampleRec.pdf = 0.0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// check if a ray could even reach the light area\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tlightSampleRec.pdf > 0.0 &&\r\n\t\t\t\t\t\t\t\tisDirectionValid( lightSampleRec.direction, normal, faceNormal ) &&\r\n\t\t\t\t\t\t\t\t! anyCloserHit( bvh, rayOrigin, lightSampleRec.direction, lightSampleRec.dist )\r\n\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t// get the material pdf\r\n\t\t\t\t\t\t\t\tvec3 sampleColor;\r\n\t\t\t\t\t\t\t\tfloat lightMaterialPdf = bsdfResult( outgoing, normalize( invBasis * lightSampleRec.direction ), surfaceRec, sampleColor );\r\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\t\t\t\t\tfloat lightPdf = lightSampleRec.pdf / float( lightCount + 1u );\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( lightPdf, lightMaterialPdf );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightSampleRec.emission * throughputColor * sampleColor * misWeight / lightPdf;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// find a sample in the environment map to include in the contribution\r\n\t\t\t\t\t\t\tvec3 envColor, envDirection;\r\n\t\t\t\t\t\t\tfloat envPdf = randomEnvMapSample( envMapInfo, envColor, envDirection );\r\n\t\t\t\t\t\t\tenvDirection = invEnvironmentRotation * envDirection;\r\n\r\n\t\t\t\t\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\r\n\t\t\t\t\t\t\t// results so we ignore the sample in this case.\r\n\t\t\t\t\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\r\n\t\t\t\t\t\t\tbool isSampleBelowSurface = dot( faceNormal, envDirection ) < 0.0;\r\n\t\t\t\t\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t\tenvPdf = 0.0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// check if a ray could even reach the surface\r\n\t\t\t\t\t\t\tvec3 attenuatedColor;\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tenvPdf > 0.0 &&\r\n\t\t\t\t\t\t\t\tisDirectionValid( envDirection, normal, faceNormal ) &&\r\n\t\t\t\t\t\t\t\t! attenuateHit( bvh, rayOrigin, envDirection, bounces - i, isShadowRay, attenuatedColor )\r\n\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t// get the material pdf\r\n\t\t\t\t\t\t\t\tvec3 sampleColor;\r\n\t\t\t\t\t\t\t\tfloat envMaterialPdf = bsdfResult( outgoing, normalize( invBasis * envDirection ), surfaceRec, sampleColor );\r\n\t\t\t\t\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\t\t\t\t\tenvPdf /= float( lightCount + 1u );\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += attenuatedColor * environmentIntensity * envColor * throughputColor * sampleColor * misWeight / envPdf;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\r\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\r\n\t\t\t\t\t\tif ( ! isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\r\n\t\t\t\t\t\t\tvec3 halfVector = normalize( outgoing + sampleRec.direction );\r\n\t\t\t\t\t\t\taccumulatedRoughness += sin( acosApprox( halfVector.z ) );\r\n\t\t\t\t\t\t\ttransmissiveRay = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// accumulate color\r\n\t\t\t\t\t\tgl_FragColor.rgb += ( emission * throughputColor );\r\n\r\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\r\n\t\t\t\t\t\tif ( sampleRec.pdf <= 0.0 || ! isDirectionValid( rayDirection, normal, faceNormal) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthroughputColor *= sampleRec.color / sampleRec.pdf;\r\n\r\n\t\t\t\t\t\t// discard the sample if there are any NaNs\r\n\t\t\t\t\t\tif ( any( isnan( throughputColor ) ) || any( isinf( throughputColor ) ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","// core\r\nexport * from './core/PathTracingRenderer.js';\r\nexport * from './core/PathTracingSceneGenerator.js';\r\nexport * from './core/DynamicPathTracingSceneGenerator.js';\r\nexport * from './core/MaterialReducer.js';\r\nexport * from './core/PhysicalCamera.js';\r\n\r\n// uniforms\r\nexport * from './uniforms/MaterialsTexture.js';\r\nexport * from './uniforms/RenderTarget2DArray.js';\r\nexport * from './uniforms/EquirectHdrInfoUniform.js';\r\nexport * from './uniforms/PhysicalCameraUniform.js';\r\n\r\n// utils\r\nexport * from './utils/GeometryPreparationUtils.js';\r\nexport * from './utils/BlurredEnvMapGenerator.js';\r\n\r\n// materials\r\nexport * from './materials/MaterialBase.js';\r\nexport * from './materials/PhysicalPathTracingMaterial.js';\r\n\r\n// shaders\r\nexport * from './shader/shaderMaterialSampling.js';\r\nexport * from './shader/shaderUtils.js';\r\nexport * from './shader/shaderStructs.js';\r\n"],"names":["FullScreenQuad"],"mappings":"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AI,CAAC,aAAa,GAAG,EAAE,CAAC;AAC1B,EAAE,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;AAC3B;AACA,EAAE;AACF;AACA,CAAC,UAAU,EAAE,MAAM,GAAG;AACtB;AACA,EAAE,KAAK,MAAM,YAAY,cAAc,GAAG;AAC1C;AACA,GAAG,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;AACrC,GAAG,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;AAC/C,GAAG,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;AACnD,GAAG,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;AAC7C,GAAG,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,eAAe,CAAC;AACjD;AACA,GAAG,MAAM;AACT;AACA,GAAG,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;AACtB,GAAG,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;AAC7B,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;AAC3B,GAAG,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;AAC3B,GAAG,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;AAC5B;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;;ACnCY,MAAC,WAAW,aAAa,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA,MAAM,iBAAiB,SAAS,YAAY,CAAC;AAC7C;AACA,CAAC,WAAW,GAAG;AACf;AACA,EAAE,KAAK,EAAE;AACT;AACA,GAAG,QAAQ,EAAE;AACb;AACA,IAAI,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;AAC3B,IAAI,IAAI,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE;AACtB;AACA,IAAI;AACJ;AACA,GAAG,YAAY,YA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACY,MAAC,iBAAiB,cAAc,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKO,MAAM,kBAAkB,aAAa,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACzGW,MAAC,sBAAsB,aAAa,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kBAAkB,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxVO,MAAM,oBAAoB,aAAa,CAAC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC1DM,MAAM,mBAAmB,aAAa,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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,EAAE,KAAK,EAAE,GAAG,EAAE;AACnC,IAAI;AACJ;AACA,GAAG,YAAY,YAAY,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,cAAc,YAAY,CAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,aAAa,EAAE;AACtB,IAAI,GAAG,uBAAuB,EAAE;AAChC,IAAI,GAAG,qBAAqB,EAAE;AAC9B,IAAI,GAAG,iBAAiB,EAAE;AAC1B;AACA,IAAI,GAAG,WAAW,EAAE;AACpB,IAAI,GAAG,sBAAsB,EAAE;AAC/B,IAAI,GAAG,oBAAoB,EAAE;AAC7B,IAAI,GAAG,mBAAmB,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CAAC;AACJ;AACA,GAAG,EAAE,CAAC;AACN;AACA,EAAE,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,CAAC;AAC/B;AACA,EAAE;AACF;AACA;;AC1vBA;;;;"}